import sys
import random
import os.path
import readline
import time
from document import Document
from problem_list import Problem_list
from submenu import Submenu

class Menu:
    '''Display a menu and respond to choices when run.'''
    def __init__(self):
        self.full_problem_list = Problem_list()
        self.choices = {
                '0': self.quit,
                '1': self.choose_sections,
                '2': self.choose_number_of_questions,
                '3': self.generate_exam
                }
        self.preferred_number_of_questions = 8
        self.preferred_problem_list = list(self.full_problem_list.list) #makes a copy of the list instead of copying the pointer
        self.covered_sections = []
        self.uncovered_sections = list(self.full_problem_list.chapter_section_list) #makes a copy of the list instead of copying the pointer

    def display_menu(self):
        print("""
Exam Builder Menu
0. Quit
1. Section coverage
2. Number of questions
3. Generate exam
""")
    #(As an aside: The menu in the example code is hardcoded, but in fact could be autogenerated, if the methods had docstrings.  "\n".join("%s: %s" % (key, action.__doc__) for key, action in sorted(self.choices.iteritems())) To properly handle a menu with >=10 items, you'd want to make the keys into integers, or expand the one-liner.)


    def run(self):
        '''Display the menu and respond to choices.'''
        while True:
            self.display_menu()
            choice = raw_input("Enter an option: ")
            action = self.choices.get(choice)
            if action:
                action()
            else:
                print("{0} is not a valid choice".format(choice))

    def generate_exam(self):
        #update preferred_problem_list
        self.update_preferred_problem_list()
        document = Document(self.preferred_problem_list)
        document.generate_exam()

    def update_preferred_problem_list(self):
        short_list = []
        for problem in self.full_problem_list.list:
            if problem.chapter_section in self.covered_sections:
                short_list += [problem]
        if len(short_list) > self.preferred_number_of_questions:
            self.preferred_problem_list = random.sample(short_list,self.preferred_number_of_questions)
        else: 
            self.preferred_problem_list = short_list

    def choose_number_of_questions(self):
        choice = raw_input("How many questions would you like?")
        try:
            self.preferred_number_of_questions = int(choice)
        except:
            print str(choice)+' is invalid. Try again.'
            self.choose_number_of_questions()

    def choose_sections(self):
        submenu = Submenu(self)
        submenu.run()
        self.uncovered_sections = list(submenu.uncovered_sections) #copy list
        self.covered_sections = list(submenu.covered_sections) #copy list

    def quit(self):
        print("Thank you for using your Exam Builder today.")
        sys.exit(0)

if __name__ == "__main__":
    Menu().run()